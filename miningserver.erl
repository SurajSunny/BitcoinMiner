-module(miningserver).
-export([startServer/2,startSupervisor/3,startMining/6]).


%% Start the server process by passing the number of leading zeroes for a bitcoin and the number of bitcoins to mine as parameters.
startServer(RequiredNumberOfZeroes, NUMBER_OF_BITCOINS_TO_MINE) ->
    %%Recording the starting time of execution.
    statistics(runtime),
    statistics(wall_clock),
    erlang:register(miner, self()),
    
    io:format("Mining started~n"),
    ExecutionStartTime = erlang:monotonic_time(),
    %%Mining 10 coins simultaneously in the server.
    if 
        NUMBER_OF_BITCOINS_TO_MINE >= 10 ->
            Supervisors_Started = 10,
            Supervisor_Pids = createSupervisor(RequiredNumberOfZeroes, Supervisors_Started, []);
        true ->
            Supervisors_Started = NUMBER_OF_BITCOINS_TO_MINE,
            Supervisor_Pids = createSupervisor(RequiredNumberOfZeroes, Supervisors_Started, [])
    end,

    startManager(Supervisor_Pids,RequiredNumberOfZeroes),
    messageHandler(Supervisor_Pids, ExecutionStartTime, RequiredNumberOfZeroes, NUMBER_OF_BITCOINS_TO_MINE, []),
    io:format("Mining completed~n").

%% Creates Supervisor nodes and returns their Pids in a list.
createSupervisor(_, Number_Of_Supervisors, Pid_List) when Number_Of_Supervisors == 0-> Pid_List;
createSupervisor(RequiredNumberOfZeroes, Number_Of_Supervisors, Pid_List) when Number_Of_Supervisors > 0->
    %%Creating supervisor processes
    Pid = spawn(?MODULE, startSupervisor, [RequiredNumberOfZeroes,self(), []]),
    createSupervisor(RequiredNumberOfZeroes, Number_Of_Supervisors-1, [Pid|Pid_List]).

%%Used by the manager to send messages to the supervisors to start their work.
startManager([],_) -> void;
startManager(Supervisor_Pids,RequiredNumberOfZeroes) ->
    [H|T] = Supervisor_Pids,
    H ! {self(), {start, RequiredNumberOfZeroes}},
    startManager(T,RequiredNumberOfZeroes).

%%Receive block for the manager process.
messageHandler([], _, _, _, _) -> io:format("Mining complete~n");
messageHandler(Supervisor_Pids, ExecutionStartTime, RequiredNumberOfZeroes, NUMBER_OF_BITCOINS_TO_MINE, Client_Pids) ->
    receive
        {From, {done, HashString, GeneratedHash, _Nonce}} ->
            %%Once a coin is mined, it is printed and if the coin is mined by the server a new supervisor is generated to mine another coin and if the coin is generated by the client, the coin is just printed.
            io:format("Bitcoin: ~s Hash Generated: ~p in ~p secs ~n",[HashString, GeneratedHash, erlang:convert_time_unit(erlang:monotonic_time() - ExecutionStartTime, native, seconds)]),
            if 
                (NUMBER_OF_BITCOINS_TO_MINE - 1) > 0 ->
                    case hd(pid_to_list(From)) =:= 60 of
                        true ->
                            %io:format("inside if ~w ~p~n", [Supervisors_Started,Supervisor_Pids]),
                            New_Supervisor_Pid = createSupervisor(RequiredNumberOfZeroes, 1, []),
                            %io:format("~p~n", New_Supervisor_Pid),
                            hd(New_Supervisor_Pid) ! {self(), {start, RequiredNumberOfZeroes}},
                            messageHandler((Supervisor_Pids -- [From]) ++ New_Supervisor_Pid, ExecutionStartTime,RequiredNumberOfZeroes, NUMBER_OF_BITCOINS_TO_MINE - 1, Client_Pids);
                        false ->
                            messageHandler(Supervisor_Pids, ExecutionStartTime,RequiredNumberOfZeroes, NUMBER_OF_BITCOINS_TO_MINE - 1, Client_Pids)
                    end;
                true ->
                    %%If mining the given number of coins is complete, calculate the runtime and elapsed time to calculate the cpu utilization.
                    {_, Time1} = statistics(runtime),
                    {_, Time2} = statistics(wall_clock),
                    %U1 = Time1 * 1000,
                    %U2 = Time2 * 1000,
                    io:format("Run time = ~p milliseconds~n Elapsed Time = ~p milliseconds~n CPU Utilization =  ~p (Runtime/Elapsed time)~n",
                    [Time1,Time2, Time1/Time2]),
                    %% Terminate the clients and the supervisors thatv are running on the server.
                    if length(Client_Pids) > 0 ->
                        terminateClients(Client_Pids);
                    true -> void
                    end,
                    if length(Supervisor_Pids) > 0 ->
                        terminateSupervisors(Supervisor_Pids);
                    true -> void
                    end,
                    %% Unregister the process and flush out the messages.
                    erlang:unregister(miner),
                    flush()
            end;
        {i_am, Pid} ->
            %% Block to receive the first message from the client once it is connected and assigning the client some work.
            io:format("~p~n",[Pid]),
            %io:format("~p~n",[{Process, Node} ! hello]),
            Pid ! {create_supervisor, RequiredNumberOfZeroes},
            messageHandler(Supervisor_Pids, ExecutionStartTime,RequiredNumberOfZeroes, NUMBER_OF_BITCOINS_TO_MINE, [Pid|Client_Pids])
    end.

%% Function to flush out the messages.
flush() ->
    receive
            _ -> flush()
    after
            0 -> ok
    end.

%% Function that sends message to client to terminate its children processes and itself.
terminateClients([])->void;
terminateClients(Client_Pids) ->
    [H|T] = Client_Pids,
    H ! {terminate},
    terminateClients(T).

%% Function that sends message to servers supervisors to terminate their workers and terminate themselves once all the bitcoins are mined.
terminateSupervisors([])->void;
terminateSupervisors(Supervisor_Pids) ->
    [H|T] = Supervisor_Pids,
    H ! {terminate_workers},
    terminateSupervisors(T).

%% Function that trerminates the workers.
terminateWorkers([]) -> void;
terminateWorkers(Worker_Pids) ->
    [H|T] = Worker_Pids,
    exit(H, kill),
    terminateWorkers(T).

%% Starting point of execution for the Supervisor process.
startSupervisor(RequiredNumberOfZeroes, Manager_Pid, Workers_Pids) ->
    Number_Of_Workers_Per_Supervisor = 10000,
    receive
        %% Receive from Manager
        {From, {start, RequiredNumberOfZeroes}} ->
        RandomString = "vnaganaboina" ++ binary_to_list(base64:encode(crypto:strong_rand_bytes(4))),  %% Generate a random string
            From ! {self(), "Creating workers to mine"},
            Worker_Pids = createWorker(RequiredNumberOfZeroes,Number_Of_Workers_Per_Supervisor, RandomString, 0, []),
            startWorker(Worker_Pids,RequiredNumberOfZeroes),
            startSupervisor(RequiredNumberOfZeroes, Manager_Pid, Worker_Pids);
        %% Receive from Workers
        {From, {done, HashString, GeneratedHash, Nonce}} ->
            Manager_Pid ! {self(), {done, HashString, GeneratedHash, Nonce}},
            terminateWorkers(Workers_Pids --[From]);
        {terminate_workers} ->
            terminateWorkers(Workers_Pids),
            flush()
    end.

%% Function to create new workers.
createWorker(_,Number_Of_Workers_Per_Supervisor, _, _, Worker_Pids) when Number_Of_Workers_Per_Supervisor == 0-> Worker_Pids;
createWorker(RequiredNumberOfZeroes,Number_Of_Workers_Per_Supervisor, RandomString, Nonce, Worker_Pids) when Number_Of_Workers_Per_Supervisor > 0->
    Step = 1000000,
    Step_Size = Step,
    Nonce_Start = Nonce*Step,
    Pid = spawn(?MODULE, startMining, [RequiredNumberOfZeroes,Number_Of_Workers_Per_Supervisor, RandomString, Nonce_Start, Step, Step_Size]),
    createWorker(RequiredNumberOfZeroes,Number_Of_Workers_Per_Supervisor-1, RandomString, Nonce+1, [Pid|Worker_Pids]).

%% Function to send message workers to start working.
startWorker([],_) -> void;
startWorker(Worker_Pids,RequiredNumberOfZeroes) ->
    [H|T] = Worker_Pids,
    H ! {self(), {start, RequiredNumberOfZeroes}},
    startWorker(T,RequiredNumberOfZeroes).

%% Execution starting point of Worker processes.
startMining(RequiredNumberOfZeroes,Number_Of_Workers_Per_Supervisor, RandomString, Nonce_Start, Step, Step_Size) ->
    receive
        {From, {start, RequiredNumberOfZeroes}} ->
            hashContent(RequiredNumberOfZeroes,Number_Of_Workers_Per_Supervisor,RandomString, Nonce_Start, Step, Step_Size, From)
    end.


%% Function that mines the coin and returns the result once a coin is mined.
hashContent(RequiredNumberOfZeroes,Number_Of_Workers_Per_Supervisor, RandomString, Nonce, Step, Step_Size, Supervisor_Pid) when Step == 0->
    hashContent(RequiredNumberOfZeroes,Number_Of_Workers_Per_Supervisor, RandomString, (Nonce + (Number_Of_Workers_Per_Supervisor*Step_Size) - Step_Size + 1), Step_Size, Step_Size, Supervisor_Pid);
hashContent(RequiredNumberOfZeroes,Number_Of_Workers_Per_Supervisor, RandomString, Nonce, Step, Step_Size, Supervisor_Pid) when Step > 0->
    HashString = RandomString++ erlang:integer_to_list(Nonce),
    GeneratedHash = sha256StringGenerator(HashString),
    NumberOfTrailingZerosAchieved = leadingZeros(GeneratedHash, RequiredNumberOfZeroes),
    if    
        NumberOfTrailingZerosAchieved == 1->
            Supervisor_Pid ! {self(), {done, HashString, GeneratedHash, Nonce}};
        true ->
            hashContent(RequiredNumberOfZeroes,Number_Of_Workers_Per_Supervisor, RandomString, Nonce+1, Step-1, Step_Size,Supervisor_Pid)
    end.

%% Function to run SHA256 algorithm on the generated string.
sha256StringGenerator(String) ->
    io_lib:format("~64.16.0b", [binary:decode_unsigned(crypto:hash(sha256,String))]).

%% Function to check the number of leading zeroes in the generated hash string.
leadingZeros(Hash, RequiredNumberOfTrailingZeros)->
    NumberOfTrailingZeros = string:length(Hash) - string:length(string:trim(Hash, leading, "0")),
    if
        NumberOfTrailingZeros >= RequiredNumberOfTrailingZeros ->
            1;
        true ->
            void
    end.
